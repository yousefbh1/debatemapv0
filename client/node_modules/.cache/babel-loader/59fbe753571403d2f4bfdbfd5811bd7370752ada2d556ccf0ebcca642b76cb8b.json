{"ast":null,"code":"import React, { memo, useRef, useEffect } from 'react';\nimport cc from 'classcat';\nimport { drag } from 'd3-drag';\nimport { select } from 'd3-selection';\nimport { useNodeId, useStoreApi, useGetPointerPosition, clamp } from '@reactflow/core';\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n  ResizeControlVariant[\"Line\"] = \"line\";\n  ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\n\n// returns an array of two numbers (0, 1 or -1) representing the direction of the resize\n// 0 = no change, 1 = increase, -1 = decrease\nfunction getDirection({\n  width,\n  prevWidth,\n  height,\n  prevHeight,\n  invertX,\n  invertY\n}) {\n  const deltaWidth = width - prevWidth;\n  const deltaHeight = height - prevHeight;\n  const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n  if (deltaWidth && invertX) {\n    direction[0] = direction[0] * -1;\n  }\n  if (deltaHeight && invertY) {\n    direction[1] = direction[1] * -1;\n  }\n  return direction;\n}\nconst initPrevValues = {\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0\n};\nconst initStartValues = {\n  ...initPrevValues,\n  pointerX: 0,\n  pointerY: 0,\n  aspectRatio: 1\n};\nfunction ResizeControl({\n  nodeId,\n  position,\n  variant = ResizeControlVariant.Handle,\n  className,\n  style = {},\n  children,\n  color,\n  minWidth = 10,\n  minHeight = 10,\n  maxWidth = Number.MAX_VALUE,\n  maxHeight = Number.MAX_VALUE,\n  keepAspectRatio = false,\n  shouldResize,\n  onResizeStart,\n  onResize,\n  onResizeEnd\n}) {\n  const contextNodeId = useNodeId();\n  const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n  const store = useStoreApi();\n  const resizeControlRef = useRef(null);\n  const startValues = useRef(initStartValues);\n  const prevValues = useRef(initPrevValues);\n  const getPointerPosition = useGetPointerPosition();\n  const defaultPosition = variant === ResizeControlVariant.Line ? 'right' : 'bottom-right';\n  const controlPosition = position ?? defaultPosition;\n  useEffect(() => {\n    if (!resizeControlRef.current || !id) {\n      return;\n    }\n    const selection = select(resizeControlRef.current);\n    const enableX = controlPosition.includes('right') || controlPosition.includes('left');\n    const enableY = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const invertX = controlPosition.includes('left');\n    const invertY = controlPosition.includes('top');\n    const dragHandler = drag().on('start', event => {\n      const node = store.getState().nodeInternals.get(id);\n      const {\n        xSnapped,\n        ySnapped\n      } = getPointerPosition(event);\n      prevValues.current = {\n        width: node?.width ?? 0,\n        height: node?.height ?? 0,\n        x: node?.position.x ?? 0,\n        y: node?.position.y ?? 0\n      };\n      startValues.current = {\n        ...prevValues.current,\n        pointerX: xSnapped,\n        pointerY: ySnapped,\n        aspectRatio: prevValues.current.width / prevValues.current.height\n      };\n      onResizeStart?.(event, {\n        ...prevValues.current\n      });\n    }).on('drag', event => {\n      const {\n        nodeInternals,\n        triggerNodeChanges\n      } = store.getState();\n      const {\n        xSnapped,\n        ySnapped\n      } = getPointerPosition(event);\n      const node = nodeInternals.get(id);\n      if (node) {\n        const changes = [];\n        const {\n          pointerX: startX,\n          pointerY: startY,\n          width: startWidth,\n          height: startHeight,\n          x: startNodeX,\n          y: startNodeY,\n          aspectRatio\n        } = startValues.current;\n        const {\n          x: prevX,\n          y: prevY,\n          width: prevWidth,\n          height: prevHeight\n        } = prevValues.current;\n        const distX = Math.floor(enableX ? xSnapped - startX : 0);\n        const distY = Math.floor(enableY ? ySnapped - startY : 0);\n        let width = clamp(startWidth + (invertX ? -distX : distX), minWidth, maxWidth);\n        let height = clamp(startHeight + (invertY ? -distY : distY), minHeight, maxHeight);\n        if (keepAspectRatio) {\n          const nextAspectRatio = width / height;\n          const isDiagonal = enableX && enableY;\n          const isHorizontal = enableX && !enableY;\n          const isVertical = enableY && !enableX;\n          width = nextAspectRatio <= aspectRatio && isDiagonal || isVertical ? height * aspectRatio : width;\n          height = nextAspectRatio > aspectRatio && isDiagonal || isHorizontal ? width / aspectRatio : height;\n          if (width >= maxWidth) {\n            width = maxWidth;\n            height = maxWidth / aspectRatio;\n          } else if (width <= minWidth) {\n            width = minWidth;\n            height = minWidth / aspectRatio;\n          }\n          if (height >= maxHeight) {\n            height = maxHeight;\n            width = maxHeight * aspectRatio;\n          } else if (height <= minHeight) {\n            height = minHeight;\n            width = minHeight * aspectRatio;\n          }\n        }\n        const isWidthChange = width !== prevWidth;\n        const isHeightChange = height !== prevHeight;\n        if (invertX || invertY) {\n          const x = invertX ? startNodeX - (width - startWidth) : startNodeX;\n          const y = invertY ? startNodeY - (height - startHeight) : startNodeY;\n          // only transform the node if the width or height changes\n          const isXPosChange = x !== prevX && isWidthChange;\n          const isYPosChange = y !== prevY && isHeightChange;\n          if (isXPosChange || isYPosChange) {\n            const positionChange = {\n              id: node.id,\n              type: 'position',\n              position: {\n                x: isXPosChange ? x : prevX,\n                y: isYPosChange ? y : prevY\n              }\n            };\n            changes.push(positionChange);\n            prevValues.current.x = positionChange.position.x;\n            prevValues.current.y = positionChange.position.y;\n          }\n        }\n        if (isWidthChange || isHeightChange) {\n          const dimensionChange = {\n            id: id,\n            type: 'dimensions',\n            updateStyle: true,\n            resizing: true,\n            dimensions: {\n              width: width,\n              height: height\n            }\n          };\n          changes.push(dimensionChange);\n          prevValues.current.width = width;\n          prevValues.current.height = height;\n        }\n        if (changes.length === 0) {\n          return;\n        }\n        const direction = getDirection({\n          width: prevValues.current.width,\n          prevWidth,\n          height: prevValues.current.height,\n          prevHeight,\n          invertX,\n          invertY\n        });\n        const nextValues = {\n          ...prevValues.current,\n          direction\n        };\n        const callResize = shouldResize?.(event, nextValues);\n        if (callResize === false) {\n          return;\n        }\n        onResize?.(event, nextValues);\n        triggerNodeChanges(changes);\n      }\n    }).on('end', event => {\n      const dimensionChange = {\n        id: id,\n        type: 'dimensions',\n        resizing: false\n      };\n      onResizeEnd?.(event, {\n        ...prevValues.current\n      });\n      store.getState().triggerNodeChanges([dimensionChange]);\n    });\n    selection.call(dragHandler);\n    return () => {\n      selection.on('.drag', null);\n    };\n  }, [id, controlPosition, minWidth, minHeight, maxWidth, maxHeight, keepAspectRatio, getPointerPosition, onResizeStart, onResize, onResizeEnd]);\n  const positionClassNames = controlPosition.split('-');\n  const colorStyleProp = variant === ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';\n  const controlStyle = color ? {\n    ...style,\n    [colorStyleProp]: color\n  } : style;\n  return React.createElement(\"div\", {\n    className: cc(['react-flow__resize-control', 'nodrag', ...positionClassNames, variant, className]),\n    ref: resizeControlRef,\n    style: controlStyle\n  }, children);\n}\nvar ResizeControl$1 = memo(ResizeControl);\nconst handleControls = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst lineControls = ['top', 'right', 'bottom', 'left'];\nfunction NodeResizer({\n  nodeId,\n  isVisible = true,\n  handleClassName,\n  handleStyle,\n  lineClassName,\n  lineStyle,\n  color,\n  minWidth = 10,\n  minHeight = 10,\n  maxWidth = Number.MAX_VALUE,\n  maxHeight = Number.MAX_VALUE,\n  keepAspectRatio = false,\n  shouldResize,\n  onResizeStart,\n  onResize,\n  onResizeEnd\n}) {\n  if (!isVisible) {\n    return null;\n  }\n  return React.createElement(React.Fragment, null, lineControls.map(c => React.createElement(ResizeControl$1, {\n    key: c,\n    className: lineClassName,\n    style: lineStyle,\n    nodeId: nodeId,\n    position: c,\n    variant: ResizeControlVariant.Line,\n    color: color,\n    minWidth: minWidth,\n    minHeight: minHeight,\n    maxWidth: maxWidth,\n    maxHeight: maxHeight,\n    onResizeStart: onResizeStart,\n    keepAspectRatio: keepAspectRatio,\n    shouldResize: shouldResize,\n    onResize: onResize,\n    onResizeEnd: onResizeEnd\n  })), handleControls.map(c => React.createElement(ResizeControl$1, {\n    key: c,\n    className: handleClassName,\n    style: handleStyle,\n    nodeId: nodeId,\n    position: c,\n    color: color,\n    minWidth: minWidth,\n    minHeight: minHeight,\n    maxWidth: maxWidth,\n    maxHeight: maxHeight,\n    onResizeStart: onResizeStart,\n    keepAspectRatio: keepAspectRatio,\n    shouldResize: shouldResize,\n    onResize: onResize,\n    onResizeEnd: onResizeEnd\n  })));\n}\nexport { ResizeControl$1 as NodeResizeControl, NodeResizer, ResizeControlVariant };","map":{"version":3,"names":["React","memo","useRef","useEffect","cc","drag","select","useNodeId","useStoreApi","useGetPointerPosition","clamp","ResizeControlVariant","getDirection","width","prevWidth","height","prevHeight","invertX","invertY","deltaWidth","deltaHeight","direction","initPrevValues","x","y","initStartValues","pointerX","pointerY","aspectRatio","ResizeControl","nodeId","position","variant","Handle","className","style","children","color","minWidth","minHeight","maxWidth","Number","MAX_VALUE","maxHeight","keepAspectRatio","shouldResize","onResizeStart","onResize","onResizeEnd","contextNodeId","id","store","resizeControlRef","startValues","prevValues","getPointerPosition","defaultPosition","Line","controlPosition","current","selection","enableX","includes","enableY","dragHandler","on","event","node","getState","nodeInternals","get","xSnapped","ySnapped","triggerNodeChanges","changes","startX","startY","startWidth","startHeight","startNodeX","startNodeY","prevX","prevY","distX","Math","floor","distY","nextAspectRatio","isDiagonal","isHorizontal","isVertical","isWidthChange","isHeightChange","isXPosChange","isYPosChange","positionChange","type","push","dimensionChange","updateStyle","resizing","dimensions","length","nextValues","callResize","call","positionClassNames","split","colorStyleProp","controlStyle","createElement","ref","ResizeControl$1","handleControls","lineControls","NodeResizer","isVisible","handleClassName","handleStyle","lineClassName","lineStyle","Fragment","map","c","key","NodeResizeControl"],"sources":["/home/yousefbh/projects/debatemapv0/client/node_modules/@reactflow/node-resizer/dist/esm/index.mjs"],"sourcesContent":["import React, { memo, useRef, useEffect } from 'react';\nimport cc from 'classcat';\nimport { drag } from 'd3-drag';\nimport { select } from 'd3-selection';\nimport { useNodeId, useStoreApi, useGetPointerPosition, clamp } from '@reactflow/core';\n\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\n\n// returns an array of two numbers (0, 1 or -1) representing the direction of the resize\n// 0 = no change, 1 = increase, -1 = decrease\nfunction getDirection({ width, prevWidth, height, prevHeight, invertX, invertY }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && invertX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && invertY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction ResizeControl({ nodeId, position, variant = ResizeControlVariant.Handle, className, style = {}, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd, }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = useRef(null);\n    const startValues = useRef(initStartValues);\n    const prevValues = useRef(initPrevValues);\n    const getPointerPosition = useGetPointerPosition();\n    const defaultPosition = variant === ResizeControlVariant.Line ? 'right' : 'bottom-right';\n    const controlPosition = position ?? defaultPosition;\n    useEffect(() => {\n        if (!resizeControlRef.current || !id) {\n            return;\n        }\n        const selection = select(resizeControlRef.current);\n        const enableX = controlPosition.includes('right') || controlPosition.includes('left');\n        const enableY = controlPosition.includes('bottom') || controlPosition.includes('top');\n        const invertX = controlPosition.includes('left');\n        const invertY = controlPosition.includes('top');\n        const dragHandler = drag()\n            .on('start', (event) => {\n            const node = store.getState().nodeInternals.get(id);\n            const { xSnapped, ySnapped } = getPointerPosition(event);\n            prevValues.current = {\n                width: node?.width ?? 0,\n                height: node?.height ?? 0,\n                x: node?.position.x ?? 0,\n                y: node?.position.y ?? 0,\n            };\n            startValues.current = {\n                ...prevValues.current,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.current.width / prevValues.current.height,\n            };\n            onResizeStart?.(event, { ...prevValues.current });\n        })\n            .on('drag', (event) => {\n            const { nodeInternals, triggerNodeChanges } = store.getState();\n            const { xSnapped, ySnapped } = getPointerPosition(event);\n            const node = nodeInternals.get(id);\n            if (node) {\n                const changes = [];\n                const { pointerX: startX, pointerY: startY, width: startWidth, height: startHeight, x: startNodeX, y: startNodeY, aspectRatio, } = startValues.current;\n                const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues.current;\n                const distX = Math.floor(enableX ? xSnapped - startX : 0);\n                const distY = Math.floor(enableY ? ySnapped - startY : 0);\n                let width = clamp(startWidth + (invertX ? -distX : distX), minWidth, maxWidth);\n                let height = clamp(startHeight + (invertY ? -distY : distY), minHeight, maxHeight);\n                if (keepAspectRatio) {\n                    const nextAspectRatio = width / height;\n                    const isDiagonal = enableX && enableY;\n                    const isHorizontal = enableX && !enableY;\n                    const isVertical = enableY && !enableX;\n                    width = (nextAspectRatio <= aspectRatio && isDiagonal) || isVertical ? height * aspectRatio : width;\n                    height = (nextAspectRatio > aspectRatio && isDiagonal) || isHorizontal ? width / aspectRatio : height;\n                    if (width >= maxWidth) {\n                        width = maxWidth;\n                        height = maxWidth / aspectRatio;\n                    }\n                    else if (width <= minWidth) {\n                        width = minWidth;\n                        height = minWidth / aspectRatio;\n                    }\n                    if (height >= maxHeight) {\n                        height = maxHeight;\n                        width = maxHeight * aspectRatio;\n                    }\n                    else if (height <= minHeight) {\n                        height = minHeight;\n                        width = minHeight * aspectRatio;\n                    }\n                }\n                const isWidthChange = width !== prevWidth;\n                const isHeightChange = height !== prevHeight;\n                if (invertX || invertY) {\n                    const x = invertX ? startNodeX - (width - startWidth) : startNodeX;\n                    const y = invertY ? startNodeY - (height - startHeight) : startNodeY;\n                    // only transform the node if the width or height changes\n                    const isXPosChange = x !== prevX && isWidthChange;\n                    const isYPosChange = y !== prevY && isHeightChange;\n                    if (isXPosChange || isYPosChange) {\n                        const positionChange = {\n                            id: node.id,\n                            type: 'position',\n                            position: {\n                                x: isXPosChange ? x : prevX,\n                                y: isYPosChange ? y : prevY,\n                            },\n                        };\n                        changes.push(positionChange);\n                        prevValues.current.x = positionChange.position.x;\n                        prevValues.current.y = positionChange.position.y;\n                    }\n                }\n                if (isWidthChange || isHeightChange) {\n                    const dimensionChange = {\n                        id: id,\n                        type: 'dimensions',\n                        updateStyle: true,\n                        resizing: true,\n                        dimensions: {\n                            width: width,\n                            height: height,\n                        },\n                    };\n                    changes.push(dimensionChange);\n                    prevValues.current.width = width;\n                    prevValues.current.height = height;\n                }\n                if (changes.length === 0) {\n                    return;\n                }\n                const direction = getDirection({\n                    width: prevValues.current.width,\n                    prevWidth,\n                    height: prevValues.current.height,\n                    prevHeight,\n                    invertX,\n                    invertY,\n                });\n                const nextValues = { ...prevValues.current, direction };\n                const callResize = shouldResize?.(event, nextValues);\n                if (callResize === false) {\n                    return;\n                }\n                onResize?.(event, nextValues);\n                triggerNodeChanges(changes);\n            }\n        })\n            .on('end', (event) => {\n            const dimensionChange = {\n                id: id,\n                type: 'dimensions',\n                resizing: false,\n            };\n            onResizeEnd?.(event, { ...prevValues.current });\n            store.getState().triggerNodeChanges([dimensionChange]);\n        });\n        selection.call(dragHandler);\n        return () => {\n            selection.on('.drag', null);\n        };\n    }, [\n        id,\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        getPointerPosition,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n    ]);\n    const positionClassNames = controlPosition.split('-');\n    const colorStyleProp = variant === ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';\n    const controlStyle = color ? { ...style, [colorStyleProp]: color } : style;\n    return (React.createElement(\"div\", { className: cc(['react-flow__resize-control', 'nodrag', ...positionClassNames, variant, className]), ref: resizeControlRef, style: controlStyle }, children));\n}\nvar ResizeControl$1 = memo(ResizeControl);\n\nconst handleControls = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst lineControls = ['top', 'right', 'bottom', 'left'];\nfunction NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd, }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (React.createElement(React.Fragment, null,\n        lineControls.map((c) => (React.createElement(ResizeControl$1, { key: c, className: lineClassName, style: lineStyle, nodeId: nodeId, position: c, variant: ResizeControlVariant.Line, color: color, minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight, onResizeStart: onResizeStart, keepAspectRatio: keepAspectRatio, shouldResize: shouldResize, onResize: onResize, onResizeEnd: onResizeEnd }))),\n        handleControls.map((c) => (React.createElement(ResizeControl$1, { key: c, className: handleClassName, style: handleStyle, nodeId: nodeId, position: c, color: color, minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight, onResizeStart: onResizeStart, keepAspectRatio: keepAspectRatio, shouldResize: shouldResize, onResize: onResize, onResizeEnd: onResizeEnd })))));\n}\n\nexport { ResizeControl$1 as NodeResizeControl, NodeResizer, ResizeControlVariant };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}